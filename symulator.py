import numpy as np
from interface import Qubit, QuantumDevice
from constants import H, KET_0, R_THETA  # Импортируем R_THETA для поворота


class SimulatedQubit(Qubit):
    def __init__(self):
        self.reset()

    def h(self):
        """Применение матрицы Адамара (50/50 распределение)."""
        self.state = H @ self.state

    def rotation(self):
        """Применение поворотной матрицы для изменения распределения."""
        self.state = R_THETA @ self.state

    def measure(self) -> bool: #смотри ниже объяснение работы этой функции
        """Измерение состояния кубита."""
        pr0 = np.abs(self.state[0, 0]) ** 2
        #вероятность состояния |0⟩, которая вычисляется как квадрат модуля амплитуды вероятности
        sample = np.random.random() <= pr0
        #генерируется случайное число от 0 до 1. Если оно меньше или равно вероятности состояния |0⟩,
        # результатом будет 0, иначе 1
        return bool(0 if sample else 1)

    def reset(self):
        """Сброс состояния кубита в |0>."""
        self.state = KET_0.copy()


class SingleQubitSimulator(QuantumDevice):
    def allocate_qubit(self) -> Qubit:
        return SimulatedQubit()

    def deallocate_qubit(self, qubit: Qubit):
        pass  # Не нужно ничего делать для симулятора



    """
    Метод `measure` в классе `SimulatedQubit` выполняет квантовое измерение состояния кубита. Давайте разберем его пошагово:

### Код метода `measure`

```python
def measure(self) -> bool:
    Измерение состояния кубита.
    pr0 = np.abs(self.state[0, 0]) ** 2
    # вероятность состояния |0⟩, которая вычисляется как квадрат модуля амплитуды вероятности

    sample = np.random.random() <= pr0
    # генерируется случайное число от 0 до 1. Если оно меньше или равно вероятности состояния |0⟩,
    # результатом будет 0, иначе 1

    return bool(0 if sample else 1)
```

### Разбор кода

1. **Вероятность состояния |0⟩:**

   ```python
   pr0 = np.abs(self.state[0, 0]) ** 2
   ```

   - `self.state` — это вектор состояния кубита. Например, для состояния `|0⟩` это будет `[1, 0]`, а для состояния суперпозиции может быть что-то вроде `[0.5, 0.5]`.
   - `self.state[0, 0]` — это амплитуда вероятности для состояния `|0⟩`. В квантовой механике, состояние кубита можно записать как линейную комбинацию базисных состояний: `α|0⟩ + β|1⟩`, где `α` и `β` — амплитуды вероятности.
   - `np.abs(self.state[0, 0])` — модуль (абсолютное значение) амплитуды вероятности для состояния `|0⟩`.
   - `np.abs(self.state[0, 0]) ** 2` — квадрат модуля амплитуды, который дает **вероятность** того, что кубит будет измерен в состоянии `|0⟩`.

2. **Генерация случайного числа и сравнение с вероятностью:**

   ```python
   sample = np.random.random() <= pr0
   ```

   - `np.random.random()` генерирует случайное число от 0 до 1 (равномерное распределение).
   - `sample` будет `True`, если случайное число меньше или равно `pr0` (вероятности состояния `|0⟩`), и `False` в противном случае.

   Это моделирует процесс измерения в квантовой механике. Если вероятность состояния `|0⟩` высока, то случайное число с большей вероятностью будет меньше или равно этой вероятности, и мы получим `True`.

3. **Возвращение результата:**

   ```python
   return bool(0 if sample else 1)
   ```

   - Если `sample` равно `True`, это означает, что кубит был измерен в состоянии `|0⟩`, и метод вернет `0`.
   - Если `sample` равно `False`, это означает, что кубит был измерен в состоянии `|1⟩`, и метод вернет `1`.

   `bool(0 if sample else 1)` — это способ преобразовать результат в булев тип. Так как `0` и `1` уже представляют собой логические значения, это можно сделать и без явного преобразования. Более просто это можно записать как:

   ```python
   return 0 if sample else 1
   ```

### Резюме

Метод `measure` моделирует процесс измерения квантового кубита следующим образом:

1. Вычисляет вероятность того, что кубит находится в состоянии `|0⟩`, основываясь на амплитуде вероятности.
2. Сравнивает случайно сгенерированное число с этой вероятностью для определения результата измерения.
3. Возвращает результат `0` или `1`, в зависимости от того, был ли кубит измерен в состоянии `|0⟩` или `|1⟩`.
    """
